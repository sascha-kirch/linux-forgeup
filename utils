#!/usr/bin/env bash

# Prevent multiple sourcing
# [ "$sourced_a_sh" != "" ] && return || sourced_a_sh=.


_bold=$(tput bold)
_normal=$(tput sgr0)
# 256 colors: https://unix.stackexchange.com/a/768209
_red=$(tput setaf 1)
_orange=$(tput setaf 3)
_blue=$(tput setaf 4)
_purple=$(tput setaf 5)

# Clear screen and print the logo
print_logo() {
    clear
    echo "
${_blue}
   ▄████████  ▄██████▄     ▄████████    ▄██████▄     ▄████████      ███    █▄     ▄███████▄
  ███    ███ ███    ███   ███    ███   ███    ███   ███    ███      ███    ███   ███    ███
  ███    █▀  ███    ███   ███    ███   ███    █▀    ███    █▀       ███    ███   ███    ███
 ▄███▄▄▄     ███    ███  ▄███▄▄▄▄██▀  ▄███         ▄███▄▄▄          ███    ███   ███    ███
▀▀███▀▀▀     ███    ███ ▀▀███▀▀▀▀▀   ▀▀███ ████▄  ▀▀███▀▀▀          ███    ███ ▀█████████▀
  ███        ███    ███ ▀███████████   ███    ███   ███    █▄       ███    ███   ███
  ███        ███    ███   ███    ███   ███    ███   ███    ███      ███    ███   ███
  ███         ▀██████▀    ███    ███   ████████▀    ██████████      ████████▀   ▄████▀
                          ███    ███
${_purple}
Linux System Setup Tool
by: Sascha Kirch
${_normal}
"
}

_log() {
    local log_level=$1
    local message=$2
    local timestamp=$(date +"%H:%M:%S")
    # local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local color

    case $log_level in
        INFO)
            color=$_blue
            ;;
        WARNING)
            color=$_orange
            ;;
        ERROR)
            color=$_red
            ;;
        CONFIG)
            color=$_purple
            ;;
        *)
            color=$_normal
            ;;
    esac

    echo "${color}${_bold} $timestamp [$log_level][FORGE-UP] ${_normal} $message"

}

log_info() {
    _log INFO "$1"
}

log_warning() {
    _log WARNING "$1"
}

log_error() {
    _log ERROR "$1"
}

log_config() {
    _log CONFIG "$1"
}

fatal(){
    log_error "FATAL: ${1}"
    exit 1
}


can_sudo(){
    groups "$(id -un)" 2>/dev/null | grep -q sudo
    if [ $? -ne 0 ]; then
        log_warning "User $(id -un) is not in the sudo group."
        return 1
    else
        log_info "User $(id -un) is in the sudo group."
        return 0
    fi
}

# Function to check if a package is installed
is_installed() {
    dpkg -s "$1" &> /dev/null
}

file_exists(){
    if [ ! -f "$1" ]; then
        log_error "File $1 does not found!"
        return 1
    else
        log_info "File $1 found."
        return 0
    fi
}

# Function to install packages if not already installed
install_apt_packages() {
    local packages=("$@")
    local to_install=()

    for pkg in "${packages[@]}"; do
        if ! is_installed "$pkg"; then
            to_install+=("$pkg")
        fi
    done

    if [ ${#to_install[@]} -ne 0 ]; then
        log_info "Installing: ${to_install[*]}"
        sudo apt-get install -y "${to_install[@]}"
    else
        log_warning "No package to be installed."
    fi
}

enable_services() {
    local services=("$@")

    for service in "${services[@]}"; do
        if ! systemctl is-enabled "$service" &> /dev/null; then
            log_info "Enabling $service..."
            sudo systemctl enable "$service"
        else
            log_warning "$service is already enabled"
        fi
    done
}

install_gh_binary() {
    local repo_name=${1} # e.g. starship/starship
    local version=${2} # e.g. v0.23.5
    local filename=${3} # e.g. starship-x86_64-unknown-linux-musl.tar.gz
    local reinstall=${4:-false} # Default is false
    local binary_name=${5:-$(basename "${repo_name}")} # if the binary name is not provided, use the repo name

    local install_dir="$HOME/.local/bin"
    local binary_path="$install_dir/$binary_name"

    if [ -f "$binary_path" ]; then
        log_warning "'$binary_name' is already installed at '$binary_path'."
        if [ "${reinstall}" = true ]; then
            log_warning "Reinstalling..."
            log_warning "Removing existing binary at '$binary_path'"
            rm -f "$binary_path"
        else
            log_warning "Skipping installation."
            return
        fi
    fi

    log_info "Installing version '$version' of repo '$repo_name' ..."
    mkdir -p "$install_dir"

    local download_url="https://github.com/$repo_name/releases/download/${version}/${filename}.tar.gz"

    log_info "Downloading from '$download_url'"
    curl -sSL "$download_url" | tar -xz -C "$install_dir"

    if [ $? -ne 0 ]; then
        log_error "Failed to download or extract '$repo_name' with link '$download_url'. Aborting installation."
        return
    fi

    # TODO: add error handling
    chmod +x "$binary_path"
    log_info "Installed version '$version' of repo '$repo_name' to '$binary_path' as '$binary_name'"
}

install_gh_package(){
    local repo_name=${1} # e.g. starship/starship
    local repo_sub_name=$(basename "${repo_name}")
    local version=${2} # e.g. v0.23.5
    local filename=${3} # e.g. starship-x86_64-unknown-linux-musl.tar.gz
    local reinstall=${4:-false} # Default is false
    local strip_components=${5:-0} # Default is 0.
    local binary_name=${6:-$repo_sub_name} # if the binary name is not provided, use the repo name
    local package_binary_subdir=${7} # if the binary is inside a subdirectory after extraction. e.g. bin/nvim => bin/

    local package_dir="$HOME/.local/packages/$repo_sub_name"
    local link_dir="$HOME/.local/bin"

    local package_binary="$package_dir/$package_binary_subdir$binary_name"
    local link_binary="$link_dir/$binary_name"

    if [ -d "$package_dir" ]; then
        log_warning "Package '$repo_sub_name' is already installed at '$package_dir'."

        if [ "${reinstall}" = true ]; then
            log_warning "Reinstalling..."

            log_warning "Removing existing package '$package_dir'"
            rm -rf "$package_dir"

            log_warning "Removing existing symlink '$link_binary'"
            rm -f "$link_binary"
        else
            log_warning "Skipping installation."
            return
        fi
    fi

    log_info "Installing version '$version' of repo '$repo_name' ..."
    mkdir -p "$package_dir"
    mkdir -p "$link_dir"

    local download_url="https://github.com/$repo_name/releases/download/${version}/${filename}.tar.gz"

    log_info "Downloading from '$download_url'"
    curl -sSL "$download_url" | tar -xz --strip-components="${strip_components}" -C "$package_dir"

    if [ $? -ne 0 ]; then
        log_error "Failed to download or extract '$repo_name' with link '$download_url'. Aborting installation."
        return
    fi

    if [ ! -f "$package_binary" ]; then
        log_error "Expected binary '$package_binary' not found after extraction. Aborting installation."
        # clean up
        rm -rf "$package_dir"
        return
    fi

    ln -sf "$package_binary" "$link_binary"
    log_info "Installed version '$version' of repo '$repo_name' to '$package_dir' and symlinked to '$link_binary'"
}

install_starship_prompt() {
    local version="${1:-v1.23.0}"
    install_gh_binary "starship/starship" "$version" "starship-x86_64-unknown-linux-musl" true
}

install_eza() {
    local version="${1:-v0.23.4}"
    install_gh_binary "eza-community/eza" "$version" "eza_x86_64-unknown-linux-musl" true
}

install_navi() {
    local version="${1:-v2.24.0}"
    install_gh_binary "denisidoro/navi" "$version" "navi-$version-x86_64-unknown-linux-musl" true
}

install_fzf(){
    local version="${1:-v0.66.0}"
    install_gh_binary "junegunn/fzf" "$version" "fzf-${version:1}-linux_amd64" true
}

install_ripgrep(){
    local version="${1:-14.1.1}"
    install_gh_package "BurntSushi/ripgrep" "$version" "ripgrep-${version}-x86_64-unknown-linux-musl" true 1 "rg"
}


install_dust(){
    local version="${1:-v1.2.3}"
    install_gh_package "bootandy/dust" "$version" "dust-${version}-x86_64-unknown-linux-musl" true 1
}

install_lazygit(){
    local version="${1:-v0.55.1}" # Default version if not provided
    install_gh_package "jesseduffield/lazygit" "$version" "lazygit_${version:1}_linux_x86_64" true
}

install_nvim() {
    local version="${1:-v0.11.4}"

    # remove any preinstalled version (e.g. those coming from ubuntu or apt)
    if is_installed neovim; then
        log_warning "Removing preinstalled neovim package"
        sudo apt remove -y neovim
    fi

    if [ -d "/usr/bin/nvim" ]; then
        log_warning "Removing preinstalled /usr/bin/nvim"
        sudo rm -rf /usr/bin/nvim
    fi

    install_gh_package "neovim/neovim" "$version" "nvim-linux-x86_64" true 1 "nvim" "bin/"
}

install_rust() {
    if command -v rustc &> /dev/null; then
        log_warning "Rust is already installed."
    else
        log_info "Installing Rust..."

        # the shell script will launch a guided installer!
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
        source $HOME/.cargo/env
        log_info "Rust installed successfully."
    fi
}

uninstall_rust() {
    if command -v rustc &> /dev/null; then
        log_info "Uninstalling Rust..."
        rustup self uninstall -y
        log_info "Rust uninstalled successfully."
    else
        log_warning "Rust is not installed."
    fi
}

install_lazydocker() {

    INSTALL_DIR="$HOME/.local/bin/lazydocker"

    if [ -f "$INSTALL_DIR" ]; then
        log_warning "lazydocker is already installed in $INSTALL_DIR"
    else
        log_info "Installing lazydocker..."
        sh -c "$(curl -fsSL https://raw.githubusercontent.com/jesseduffield/lazydocker/master/scripts/install_update_linux.sh)"
    fi

    # Note it is installed into .local/bin so make sure it is added to the $PATH. e.g. inside of ~/.profile
}

install_zoxide() {

    INSTALL_DIR="$HOME/.local/bin/zoxide"

    if [ -f "$INSTALL_DIR" ]; then
        log_warning "zoxide is already installed in $INSTALL_DIR"
    else
        log_info "Installing zoxide..."
        sh -c "$(curl -fsSL https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh)"
    fi

    # Note it is installed into .local/bin so make sure it is added to the $PATH. e.g. inside of ~/.profile
}

install_vim_pluginmanager() {
    if ! is_installed vim; then
        log_error "vim is not installed. Please install vim first."
        return
    fi

    log_info "Installing vim-plug plugin manager..."
    curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

}

install_vim_plugins() {
    if ! is_installed vim; then
        log_error "vim is not installed. Please install vim first."
        return
    fi

    # Check if vim-plug is installed
    if [ ! -f ~/.vim/autoload/plug.vim ]; then
        log_error "vim-plug is not installed. Please run install_vim_pluginmanager first."
        return
    fi

    # Install plugins using vim-plug
    log_info "Installing vim plugins..."
    vim +PlugInstall +qall
}

install_tmux_plugin_manager() {

    if ! is_installed tmux; then
        log_error "tmux is not installed. Please install tmux first."
        return
    fi

    TPM_DIR="$HOME/.tmux/plugins/tpm"

    # Check if TPM is already installed
    if [ -d "$TPM_DIR" ]; then
        log_warning "TPM is already installed in $TPM_DIR"
    else
        log_info "Installing Tmux Plugin Manager (TPM)..."
        git clone https://github.com/tmux-plugins/tpm $TPM_DIR
    fi

    log_info "TPM installed successfully!"
}

install_tmux_catppuccin(){
    CATPPUCCIN_DIR=~/.config/tmux/plugins/catppuccin

    if [ -d "$CATPPUCCIN_DIR" ]; then
        log_warning "Catppuccin is already installed in $CATPPUCCIN_DIR"
    else
        log_info "Installing Tmux Catppuccin theme..."
        mkdir -p $CATPPUCCIN_DIR
        git clone -b v2.1.3 https://github.com/catppuccin/tmux.git $CATPPUCCIN_DIR/tmux
    fi
}



# When seting up tmux there is some manual cloning of repositories involved. The dotfiles are not managed by GNU Stow
setup_tmux(){
    install_tmux_plugin_manager
    # install_tmux_catppuccin
}

setup_dotfiles() {
    log_info "Setting up dotfiles..."

    DOTFILES_REPO_NAME="dotfiles"
    DOTFILES_REPO="https://github.com/sascha-kirch/$DOTFILES_REPO_NAME.git"
    DOTFILES_DIR="$HOME/$DOTFILES_REPO_NAME"

    source dotfiles.conf

    if ! is_installed stow; then
        log_error "GNU Stow is not installed, install it first"
        return
    fi

    # Check if the repository already exists
    if [ -d "$DOTFILES_DIR" ]; then
        log_warning "Directory '$DOTFILES_DIR' already exists. Skipping clone"
    else
        git clone "$DOTFILES_REPO" "$DOTFILES_DIR"
    fi

    # Check if the clone was successful
    if [ $? -eq 0 ]; then
        log_info "Cloning the repository was successful."
    else
        log_error "Failed to clone the repository."
        return
    fi
}


# TODO: stow files individually and check for errors
stow_dotfiles() {
    local dotfiles=("$@")

    pushd "$HOME/dotfiles"

    if [ ${#dotfiles[@]} -ne 0 ]; then
        log_info "Stowing dotfiles: ${dotfiles[*]}"
        stow -R "${dotfiles[@]}"
    else
        log_warning "No dotfiles to be stowed."
    fi

    popd
    log_info "Dotfiles stowed successfully."
}
